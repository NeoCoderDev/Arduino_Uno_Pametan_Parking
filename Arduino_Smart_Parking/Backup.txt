#include <DHT.h>
#include <DHT_U.h>



#include <LiquidCrystal_I2C.h>

#define servoPin 2

#include <U8g2lib.h>
#include <Servo.h> 



#define trigPin_3 43
#define echoPin_3 42








Servo ServoRampa;



#define DHTPIN 42      // Pin na koji je povezan DHT11 senzor
#define DHTTYPE DHT11 // Definiše tip senzora (DHT11)

DHT dht(DHTPIN, DHTTYPE); // Inicijalizacija senzora

int rxPin = 17; // RX2 pin na Arduino Mega
int txPin = 16; // TX2 pin na Arduino Mega

bool alarmAktiviran = false;



int IR_Ulaz = 6;
int IR_Izlaz = 7;

int ParkingMesta = 3; 
int ZauzetaMesta = 0;          

int Prvo_Stanje = 0;
int Drugo_Stanje = 0;

int piezoPin = 3; 

long distance;





long distance_2;

long distance_3;


int buttonUlaz = 4;

int buttonState = 0;  // Trenutno stanje tastera

int lastButtonState = 0;  // Prethodno stanje tastera

bool isOpen = false; 

bool carDetected = false;  
bool carDetected2 = false;  

const int AnalogWaterPin = A5;

const int SemaforCrvno_1 = 22;
const int SemaforZuto_1 = 23;
const int SemaforZeleno_1 = 24;


const int SemaforCrvno_2 = 38;
const int SemaforZuto_2 = 39;
const int SemaforZeleno_2 = 40;

const int SenzorPlamena = A0;
const int pragAktivacije = 60; // Prag za aktivaciju alarma

const int PumpPin = A2; // Pin na koji je povezan prekidač
const int relayPin = A1;


const int VentilatorPin = A6;
const int ReleyPinFan = A7;

bool espConnected = false;  // Promenljiva koja prati status konekcije ESP8266


enum StanjeSemafora {
  CRVENO,
  ZELENO,
  BLINK_ZELENO,
  ZUTO_1,
  ZUTO_2
};

StanjeSemafora trenutnoStanje = CRVENO;

StanjeSemafora trenutnoStanje2 = ZELENO;

unsigned long prethodniMillis = 0;

unsigned long prethodniMillis2 = 0;

const long trajanjeCrvenog = 7000;  // Trajanje crvenog svetla u milisekundama
const long trajanjeZelenog = 7000;  // Trajanje zelenog svetla u milisekundama
const long trajanjeBlinkanja = 4000; // Trajanje blinkanja zelenog svetla u milisekundama
const long trajanjeZutog = 2000;    // Trajanje žutog svetla u milisekundama

unsigned long blinkMillis = 0;  // Vreme za blinkanje zelenog svetla
bool zelenoBlinkStanje = false; // Trenutno stanje blinkanja zelenog svetla
//------------------------------------------------------------------------------------------------------
bool zelenoBlinkStanje2 = false; // Trenutno stanje blinkanja zelenog svetla drugog semafora

unsigned long blinkMillis2 = 0;  // Vreme za blinkanje zelenog svetla drugog semafora


// Definišemo minimalnu i maksimalnu udaljenost (u centimetrima)
const int minDistance = 5;    // Minimalna udaljenost (najbliže senzoru)
const int maxDistance = 10;  // Maksimalna udaljenost (najdalje od senzora)

// Ako koristite ST7920 sa SPI interfejsom
U8G2_ST7920_128X64_F_SW_SPI u8g2(U8G2_R0, /* clock=*/ 13, /* data=*/ 11, /* CS=*/ 10, /* reset=*/ 8);

void setup()
 {
  dht.begin(); // Pokretanje DHT senzora
  Serial.begin(9600);    // Serijska komunikacija sa računarom
  Serial2.begin(115200); // Serijska komunikacija sa ESP8266 (RX2/TX2)
  Serial.println("Arduino Mega ready");

  Serial2.println("Are you there, ESP8266?"); // Šalji proveru na ESP8266

  pinMode(PumpPin, INPUT_PULLUP);
  pinMode(relayPin, OUTPUT);   
  digitalWrite(relayPin, LOW);       // Početno stanje releja je isključeno

  

  pinMode(VentilatorPin,INPUT_PULLUP);

  pinMode(ReleyPinFan, OUTPUT);
  digitalWrite(ReleyPinFan, LOW); 

 pinMode(buttonUlaz, INPUT_PULLUP);   


  pinMode(31, OUTPUT);  // Trig pin kao izlaz
  pinMode(30, INPUT);   // Echo pin kao ulaz

  pinMode(50, OUTPUT);  // Trig pin kao izlaz
  pinMode(51, INPUT);   // Echo pin kao ulaz


  pinMode(45, OUTPUT);  // Trig pin kao izlaz
  pinMode(44, INPUT);   // Echo pin kao ulaz
  u8g2.begin(); // Inicijalizacija displeja
  u8g2.setContrast(255); // Postavljanje maksimalnog kontrasta
  pinMode(IR_Ulaz, INPUT);
  pinMode(IR_Izlaz, INPUT);





  pinMode(SemaforCrvno_1,OUTPUT);
  pinMode(SemaforZuto_1,OUTPUT);
  pinMode(SemaforZeleno_1,OUTPUT);

  digitalWrite(SemaforCrvno_1, LOW);
  digitalWrite(SemaforZuto_1, LOW);
  digitalWrite(SemaforZeleno_1, LOW);

  pinMode(SemaforCrvno_2, OUTPUT);
  pinMode(SemaforZuto_2, OUTPUT);
  pinMode(SemaforZeleno_2, OUTPUT);

  digitalWrite(SemaforCrvno_2, LOW);
  digitalWrite(SemaforZuto_2, LOW);
  digitalWrite(SemaforZeleno_2, LOW);

  pinMode(SenzorPlamena,INPUT);

   

  trenutnoStanje = CRVENO;
  prethodniMillis = millis();

  trenutnoStanje2 = ZELENO;
  prethodniMillis2 = millis();
    
  ServoRampa.attach(servoPin);
  ServoRampa.write(0);
}
void loop()
{
  int stanjeVatre = analogRead(SenzorPlamena); // Čitanje vrednosti sa senzora plamena
  Serial.println(stanjeVatre); // Ispisuje vrednost senzora na serijski monitor za debagovanje

  if (stanjeVatre < pragAktivacije) { // Ako je vrednost ispod praga (požar detektovan)
    tone(piezoPin, 1500);  // Aktivira pištanje buzera
  } else {
    noTone(piezoPin);  // Isključuje pištanje buzera
  }

  delay(100);  // Pauza između očitavanja

  Semafori();
  ProveraKonekcije();
  KontrolaVodenePumpe();
  KontrolaVentilacije();
  Vodostaj();
  kontrolaUlazaIzlaza();
  DHTSenzor();

//----------------------------------NIVO VODE------------------------------------------------------------------

//-----------------------------------------PARKING SENZOR 1-----------------------------------------------------------
long distance = readUltrasonic(31, 30);
long distance_2 = readUltrasonic(50, 51);
  controlBuzzer(distance);
  delay(100); // Mala pauza između merenja
  
  controlBuzzer(distance_2);  // Kontroliše pištanje za drugi senzor
    delay(100); // Mala pauza između merenja

  delay(100); // Kratka pauza pre sledećeg čitanja

  if (distance < 5) 
  {
    if (!carDetected) 
    {
      carDetected = true;  // Označi da je auto detektovan
      if (ParkingMesta > 0) 
      {
        ParkingMesta--;  // Smanji broj slobodnih parking mesta
        ZauzetaMesta++;
      }
    }
  }
  else 
  {
    if (carDetected)
    {
      carDetected = false;  // Resetuj detekciju kada auto ode
      ParkingMesta++;
      ZauzetaMesta--;
    }
  }

  
  if (distance_2 < 5) 
  {
    if (!carDetected2) 
    {
      carDetected2 = true;  // Označi da je auto detektovan
      if (ParkingMesta > 0) 
      {
        ParkingMesta--;  // Smanji broj slobodnih parking mesta
        ZauzetaMesta++;
      }
    }
  }
  else 
  {
    if (carDetected2)
    {
      carDetected2 = false;  // Resetuj detekciju kada auto ode
      ParkingMesta++;
      ZauzetaMesta--;
    }
  }
//-----------------------------------------------
//---------------SPUŠTANJE RAMPE----------------------------
//-----------------------------------------------
if(Prvo_Stanje==1 && Drugo_Stanje==1)
{
    ZatvoriRampu();
    Prvo_Stanje=0, Drugo_Stanje=0;
}
//----------------------------------------------
  u8g2.clearBuffer();          // Brisanje bafera
  u8g2.setFont(u8g2_font_ncenB08_tr); // Postavljanje fonta
  u8g2.setCursor(0, 10);
  u8g2.print("Slob. mesta: ");
  u8g2.print(ParkingMesta);
  u8g2.setCursor(0, 24);
  u8g2.print("Zauz. mesta: ");
  u8g2.print(ZauzetaMesta);
//------------------------PARKINZI NA DISPLEJU
  u8g2.setCursor(0, 35);
  u8g2.print("P1: ");
  u8g2.print(distance);
  
  u8g2.setCursor(55, 35);
  u8g2.print("P2: ");
  u8g2.print(distance_2);

  u8g2.setCursor(55, 45);
  u8g2.print("P3: ");
  u8g2.print(distance_3);
//------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------
}


//----------------------------------------------------------------------VOIDI 
void DHTSenzor()
{
    // Očitavanje temperature i vlažnosti
  float temperatura = dht.readTemperature();
  float vlaznost = dht.readHumidity();

  // Provera da li su očitavanja uspešna
  if (isnan(temperatura) || isnan(vlaznost)) {
    Serial.println("Greska pri ocitavanju DHT senzora!");
    return;
  }

  // Ispisivanje očitanih vrednosti na serijski monitor
  Serial.print("Vlaznost: ");
  Serial.print(vlaznost);
  Serial.print(" %\t");
  Serial.print("Temperatura: ");
  Serial.print(temperatura);
  Serial.println(" *C");

  delay(100); // Čeka 2 sekunde pre sledećeg očitavanja
}
void prikaziTekst(int tekstIndex) 
{
  u8g2.clearBuffer();

  switch (tekstIndex) {
    case 0:
      u8g2.drawStr(0, 24, "Dobrodosli!"); // Prikazuje prvi tekst
      break;
  }

  u8g2.sendBuffer(); // Slanje bafera na displej
}
unsigned long prethodnoVremeUlaz = 0;
const unsigned long vremeCekanja = 100; // Vreme čekanja od 100 milisekundi za debounce
void kontrolaUlazaIzlaza() 
{
  unsigned long trenutnoVreme = millis();
  // Provera stanja tastera za otvaranje rampe
  buttonState = digitalRead(buttonUlaz); // Čitanje trenutnog stanja tastera
  if (buttonState != lastButtonState && (trenutnoVreme - prethodnoVremeUlaz >= vremeCekanja)) {
    if (buttonState == LOW) {
      OtvoriRampu();
      isOpen = true;
    }
    isOpen = !isOpen; // Promena stanja rampe
    prethodnoVremeUlaz = trenutnoVreme; // Ažuriraj vreme ulaza
  }
  
  // Provera ulaza na parking
  if (digitalRead(IR_Ulaz) == LOW && Prvo_Stanje == 0) 
  {
    Prvo_Stanje = 1;
  }

  // Provera izlaza sa parkinga
  if (digitalRead(IR_Izlaz) == LOW && Drugo_Stanje == 0 && (trenutnoVreme - prethodnoVremeUlaz >= vremeCekanja)) 
  {
    Drugo_Stanje = 1;
    if (Prvo_Stanje == 0) 
    {
      OtvoriRampu();
    }
    prethodnoVremeUlaz = trenutnoVreme; // Ažuriraj vreme izlaza
  }



  lastButtonState = buttonState; // Skladištenje trenutnog stanja tastera za sledeću iteraciju
}
void Vodostaj() {
  int NivoVode = analogRead(AnalogWaterPin); // Čitanje nivoa vode sa analognog pina

  u8g2.setCursor(0, 55); // Podešavanje kursora za prikaz na ekranu
  u8g2.print("Voda:  ");
  u8g2.print(NivoVode); // Prikazivanje nivoa vode
  u8g2.sendBuffer();  // Slanje bafera na displej

  delay(100); // Mala pauza pre sledećeg osvežavanja
}
void KontrolaVentilacije() {
  int StanjeVentilatora = digitalRead(VentilatorPin);
  digitalWrite(ReleyPinFan, (StanjeVentilatora == LOW) ? HIGH : LOW);
}
void KontrolaVodenePumpe() {
  int StanjePumpe = digitalRead(PumpPin);
  digitalWrite(relayPin, (StanjePumpe == LOW) ? HIGH : LOW);
}
void ProveraKonekcije()
{
    if (Serial.available()) {
    String command = Serial.readStringUntil('\n'); // Čita komandu sa serijskog porta
    command.trim(); // Uklanja eventualne razmake i prazne redove

    if (command == "RESERVE1" || command == "RESERVE2" || command == "RESERVE3") {
      if (ParkingMesta > 0) {
        ParkingMesta--;  // Smanjuje broj slobodnih parking mesta
        ZauzetaMesta++;  // Povećava broj zauzetih parking mesta
        Serial.println("Parking mesto je rezervisano.");
      } else {
        Serial.println("Nema dostupnih parking mesta.");
      }
    }
  }
}
void Semafori()
{
  unsigned long trenutniMillis = millis();
unsigned long trenutniMillis2 = millis();

  switch (trenutnoStanje)
  {
   case CRVENO:
      digitalWrite(SemaforCrvno_1, HIGH);
      digitalWrite(SemaforZuto_1, LOW);
      digitalWrite(SemaforZeleno_1, LOW);
      if (trenutniMillis - prethodniMillis >= trajanjeCrvenog) {
        trenutnoStanje = ZUTO_1;
        prethodniMillis = trenutniMillis;
      }
      break;
    case ZUTO_1:
      digitalWrite(SemaforCrvno_1, LOW);
      digitalWrite(SemaforZuto_1, HIGH);
      digitalWrite(SemaforZeleno_1, LOW);
      if (trenutniMillis - prethodniMillis >= trajanjeZutog) {
        trenutnoStanje = ZELENO;
        prethodniMillis = trenutniMillis;
      }
      break;
    case ZELENO:
      digitalWrite(SemaforCrvno_1, LOW);
      digitalWrite(SemaforZuto_1, LOW);
      digitalWrite(SemaforZeleno_1, HIGH);
      if (trenutniMillis - prethodniMillis >= trajanjeZelenog) {
        trenutnoStanje = BLINK_ZELENO;
        prethodniMillis = trenutniMillis;
        blinkMillis = trenutniMillis;
      }
      break;

    case BLINK_ZELENO:
      if (trenutniMillis - blinkMillis >= 500) {
        blinkMillis = trenutniMillis;
        zelenoBlinkStanje = !zelenoBlinkStanje;
        digitalWrite(SemaforZeleno_1, zelenoBlinkStanje ? HIGH : LOW);
      }
      if (trenutniMillis - prethodniMillis >= trajanjeBlinkanja) {
        trenutnoStanje = ZUTO_2;
        prethodniMillis = trenutniMillis;
      }
      break;

    case ZUTO_2:
      digitalWrite(SemaforCrvno_1, LOW);
      digitalWrite(SemaforZuto_1, HIGH);
      digitalWrite(SemaforZeleno_1, LOW);
      if (trenutniMillis - prethodniMillis >= trajanjeZutog) {
        trenutnoStanje = CRVENO;
        prethodniMillis = trenutniMillis;
      }
      break;
  }

  switch (trenutnoStanje2) {
    case ZELENO:
      digitalWrite(SemaforCrvno_2, LOW);
      digitalWrite(SemaforZuto_2, LOW);
      digitalWrite(SemaforZeleno_2, HIGH);
      if (trenutniMillis2 - prethodniMillis2 >= trajanjeZelenog) {
        trenutnoStanje2 = BLINK_ZELENO;
        prethodniMillis2 = trenutniMillis2;
        blinkMillis2 = trenutniMillis2;
      }
      break;

    case BLINK_ZELENO:
      if (trenutniMillis2 - blinkMillis2 >= 500) {
        blinkMillis2 = trenutniMillis2;
        zelenoBlinkStanje2 = !zelenoBlinkStanje2;
        digitalWrite(SemaforZeleno_2, zelenoBlinkStanje2 ? HIGH : LOW);
      }
      if (trenutniMillis2 - prethodniMillis2 >= trajanjeBlinkanja) {
        trenutnoStanje2 = ZUTO_1;
        prethodniMillis2 = trenutniMillis2;
      }
      break;

    case ZUTO_1:
      digitalWrite(SemaforCrvno_2, LOW);
      digitalWrite(SemaforZuto_2, HIGH);
      digitalWrite(SemaforZeleno_2, LOW);
      if (trenutniMillis2 - prethodniMillis2 >= trajanjeZutog) {
        trenutnoStanje2 = CRVENO;
        prethodniMillis2 = trenutniMillis2;
      }
      break;

    case CRVENO:
      digitalWrite(SemaforCrvno_2, HIGH);
      digitalWrite(SemaforZuto_2, LOW);
      digitalWrite(SemaforZeleno_2, LOW);
      if (trenutniMillis2 - prethodniMillis2 >= trajanjeCrvenog) {
        trenutnoStanje2 = ZUTO_2;
        prethodniMillis2 = trenutniMillis2;
      }
      break;
    case ZUTO_2:
      digitalWrite(SemaforCrvno_2, LOW);
      digitalWrite(SemaforZuto_2, HIGH);
      digitalWrite(SemaforZeleno_2, LOW);
      if (trenutniMillis2 - prethodniMillis2 >= trajanjeZutog) {
        trenutnoStanje2 = ZELENO;
        trenutniMillis2 = trenutniMillis2;
      }
      break;
  }
}

// Funkcija za spuštanje rampe
void OtvoriRampu()
{
  slowMove(ServoRampa, 0, 90, 10); 

}
void ZatvoriRampu() 
{
  slowMove(ServoRampa, 90, 0, 10); 
}
void PunParking()
{
  u8g2.setFont(u8g2_font_ncenB08_tr); // Postavljanje fonta
  u8g2.setCursor(0, 50);
  u8g2.print("Parking je pun!");
  u8g2.sendBuffer();           // Slanje bafera na displej
  tone(piezoPin, 255); 
  delay(1000);  // Pauza od 1 sekunde
  noTone(piezoPin);
}
//----------------------------------
//---------------------------------------

// Funkcija za sporo pomeranje servo motora
void slowMove(Servo &servo, int start, int end, int delayTime) 
{
  if (start < end) {
    for (int pos = start; pos <= end; pos++) {
      servo.write(pos);  // Postavljanje pozicije servo motora
      delay(delayTime);  // Pauza za usporavanje kretanja
    }
  } else {
    for (int pos = start; pos >= end; pos--) {
      servo.write(pos);  // Postavljanje pozicije servo motora
      delay(delayTime);  // Pauza za usporavanje kretanja
    }
  }
}
long readUltrasonic(int trigPin, int echoPin) 
{
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH);
  long distance = (duration * 0.034) / 2;

  return distance;
}
void controlBuzzer(long distance) {
  if (distance > 0 && distance < 5) { // Podesite maksimalnu udaljenost za detekciju
    int frequency = map(distance, 0, 5, 2000, 100); // Invertovana logika: bliže objekat -> viša frekvencija
    tone(piezoPin, frequency, 100); // Pišti 100 ms
  } else {
    noTone(piezoPin); // Zaustavi pištanje ako nema detekcije ili je objekat predaleko
  }
}
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
void updateLCD() {
  u8g2.clearBuffer(); 
  u8g2.setFont(u8g2_font_ncenB08_tr); 
  u8g2.setCursor(0, 10);
  u8g2.print("Slob. mesta: ");
  u8g2.print(ParkingMesta);
  u8g2.setCursor(0, 24);
  u8g2.print("Zauz. mesta: ");
  u8g2.print(ZauzetaMesta);
  u8g2.sendBuffer();
}
